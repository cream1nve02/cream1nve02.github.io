---

layout: single
title:  "Docker A부터 Z까지!"
categories: Development
tag: [docker]
toc: true
toc_sticky: true
toc_label: 목차
toc_icon: "fas fa-water"
author_profile: false
typora-root-url: ../
search: true
use_math: true
sidebar:
    nav: "counts"
---

개발을 하는데 도커를 모른다? 그냥 이 글 보고 따라서 해라. 모른다고 안쓰면 나중에 후회할테니 몰라도 따라서 그냥 한 번 해보기를 추천한다. 하다 보면, 어느 순간 이해하게 된다.

# 가상화(virtualization)

## 가상화란

도커를 이해하기 앞서, 가상화에 대해 이해할 필요가 있다. 가상화란 물리적인 컴퓨팅 환경 내부에서 논리적인 컴퓨팅 환경을 만들어내는 기술을 말한다. 그냥 들으면 도대체 이걸 굳이 왜 하는지 궁금할 수 있다. 이유를 한 줄로 요약하면, 

**격리된 개발 환경을 만들기 위해서다.**

일반적으로, 우리가 사용하는 PC를 생각해보자. 보통의 경우, 하드웨어 하나에 OS 하나를 설치하고 그 위에서 각자가 필요한 프로그램들을 설치해서 사용한다. 일반적인 사용자들의 경우 이렇게 사용하더라도 큰 문제가 생길 위험이 크게 없다. 만일 생기더라도 재부팅하는 식의 방법으로 간단하게 해결하면 그만이다. 

하지만, 기업에서 소프트웨어를 개발하고 운영하는 과정에서 소프트웨어 간의 간섭으로 문제가 발생한다면, 단순히 재부팅하는 수준의 문제가 아닐 것이다. 경제적, 시간적 비용이 막대하게 생길 것이 뻔하며, 이를 방지하기 위해 가상화 기술이 반드시 필요하다.



가상화 기술을 사용하지 않는 경우와 사용하는 경우를 아래와 같이 정리할 수 있다.

## 단일 OS에서 여러 개의 소프트웨어를 동작시키는 상황 (Baremetal)

* 특정 프로그램의 사용량이 급증하거나, 문제를 일으켜 다른 프로그램의 동작을 방해할 수 있다.

## 가상화 기술을 통해 생성된 여러 OS를 사용하여  소프트웨어를 동작시키는 상황 (Virtualiztion)

* 가상화 기술을 사용하면 한 대의 컴퓨터에서 여러 대의 논리적인 OS 환경을 만들 수 있다.
* 이때, 사용자가 개별 OS에서 사용할 리소스를 직접 분배가 가능하다.
* 개별 OS에서 실행되는 각각의 프로그램들은 논리적으로 격리되어 실행된다.



## 가상화 방식

가상화를 하는 방식은 크게 **하이퍼바이저 방식**과 **컨테이너 방식** 둘로 분류한다. 

### 하이퍼바이저(Hypervisor) 가상화

* 하이퍼바이저 가상화는 말 그대로 하이퍼바이저라는 소프트웨어 기술을 통해 구현되는 가상화 방식이다.
* 하이퍼바이저는 간단하게 컴퓨터에 설치되는 프로그램 정도로 이해하면 괜찮다.
* 즉, 하이퍼바이저라는 프로그램을 OS 위에서 구동시켜서 가상화 환경을 관리한다.
* 가상 OS를 만들면 사용자가 지정해놓은 CPU와 메모리 만큼 컴퓨터의 격리된 공간을 만들어낼 수 있다.
* 가상 환경을 만들 때마다 사용자가 지정한 만큼의 디스크 공간, CPU, 메모리를 사용하게 된다.
* 여기서 하이퍼바이저가 구동되는 OS를 호스트 OS라고 부르며, 하이퍼바이저에 의해 생성된 가상화 OS들을 게스트 OS라고 부른다.
* 호스트 OS : 물리적인 서버에 설치되는 OS
  * 하이퍼바이저를 설치해서 가상환경을 만들 수 있다.
  * 하이퍼바이저는 호스트 OS의 자원을 격리해서 새로운 OS를 만들어 실행한다.
* 게스트 OS : 하이퍼바이저를 통해 생성된 OS
  * 호스트 OS의 리소스를 나누어 만들어진 논리적인 공간
  * 일반적으로 가상머신이라고 부른다.
  * Web Server나 WAS, DB 같은 서버 프로그램을 프로세스 형태로 실행해서 운영한다.
* 가상화 과정 (상세)
  * 프로세스가 정상적으로 실행되기 위해서는 CPU, 메모리와 같은 하드웨어 자원이 필요하다. 하지만, 프로세스는 하드웨어 자원에 임의로 접근할 수 없도록 설계되어 있다. 하드웨어 자원을 사용하는 것은 아주 복잡하고 조심스러운 과정이기 때문이다.
  * 프로세스가 하드웨어에 접근하기 위해서 OS에 설치된 커널을 거쳐야만 한다. 커널은  **시스템 콜(system call)**이라는 표준을 통해 하드웨어 자원 사용 요청을 대신 전달한다.
  * 보통 사용하는 프로그램들 역시 실행될 때 프로세스들은 OS의 커널에게 하드웨어 자원을 요청하여 사용한다.
  * 게스트 OS들은 실제로 물리적인 하드웨어가 없기 때문에 호스트 OS에 설치된 커널을 통해 하드웨어 자원 사용을 요청해야 한다.
  * 하지만, 호스트 OS와 게스트 OS가 종류가 다르다면, 호스트 OS는 게스트 OS에서 전달받은 시스템 콜(system call)을 처리할 수 없다.
  * 이때, 하이퍼바이저가 서로 다른 커널 간의 언어를 통역하는 역할을 하여 게스트 OS의 시스템콜을 호스트 OS가 처리할 수 있도록 해준다. 
  * 커널 간 번역 과정을 거쳐가기에 처리 과정이 복잡하며 이를 **오버헤드가 크다**고 표현한다.

### 컨테이너(Container) 가상화

* 컨테이너 가상화는 도커가 사용하는 가상화 방식이다.
* 하이퍼바이저 없이 리눅스 커널이 제공하는 LXC(LinuX Containers)라는 자체 격리 기술을 활용하여 가상화를 수행한다.
* 커널의 격리 기능을 활용하기 때문에 모든 컨테이너들은 호스트 OS의 커널을 공유한다.
* 호스트 OS의 커널을 그대로 사용하므로 중간 단계가 없으며 하드웨어 자원 사용 요청이 더욱 효율적으로 이루어질 수 있다. 이를 **오버헤드가 적다**라고 표현한다.
* 컨테이너들은 자체적인 커널을 가지지 않고 호스트 OS의 커널을 공유하기에 커널 실행 시간 자체가 없으며 매우 **빠른 부팅**이 가능하다.
* 보안적인 측면에서는, 커널을 독립적으로 가지는 하이퍼바이저 방식이 조금 더 뛰어나다고 볼 수 있다.
* 컨테이너는 호스트 OS의 커널을 공유하기 때문에 호스트 OS와 다른 종류의 OS는 실행할 수 없다는 것이 가장 큰 단점이다.

---



# 도커 (Docker)

## 도커란

* 컨테이너 가상화를 하기 위한 도구이다.
* 컨테이너 플랫폼
  * 컨테이너 엔진
    * 사용자의 요청을 받아 컨테이너를 관리한다.
  * 컨테이너 런타임
    * 직접 커널과 통신하면 실제로 격리된 공간을 만든다.
    * runc : 도커가 지원하는 기본 컨테이너 런타임

## 도커 아키텍쳐

* Client - Server 모델로 실행된다.
* Client : 사용자의 명령을 Docker Demon이라는 서버에 전달한다.
* Demon Server : 실제로 컨테이너를 관리해주는 기능을 제공하며 도커D라고도 부른다.
  * 호스트 OS에서 지속적으로 실행되면서 클라이언트의 요청에 따라서 컨테이너를 관리한다
  * 호스트 OS의 커널의 기능을 활용하여 컨테이너를 관리한다.
  * Client가 원하는 기능을 실행할 수 있도록 API를 제공한다.
    * API :  상호 간의 주고받는 데이터의 약속된 양식을 의미한다.
  * 컨테이너를 생성하려면 컨테이너 생성 api 요청을 보내야하고, 삭제하려면 삭제 api 요청을 보내야 한다.







