---

layout: single
title:  "Docker A부터 Z까지!(이론편 PART1)"
categories: Docker
tag: [docker]
toc: true
toc_sticky: true
toc_label: 목차
toc_icon: "fas fa-water"
author_profile: false
typora-root-url: ../
search: true
use_math: true
sidebar:
    nav: "counts"
---

개발을 하는데 도커를 모른다???

그냥 이 글 한 번 보면 이해할 수 있다. 쭉 한 번 읽고 모르면 한 번 더 읽어라.

---

# 가상화(virtualization)

## 가상화란

도커를 이해하기 앞서, 가상화에 대해 이해할 필요가 있다. 가상화란 물리적인 컴퓨팅 환경 내부에서 논리적인 컴퓨팅 환경을 만들어내는 기술을 말한다. 그냥 들으면 도대체 이걸 굳이 왜 하는지 궁금할 수 있다. 이유를 한 줄로 요약하면, 

**격리된 개발 환경을 만들기 위해서다.**

일반적으로, 우리가 사용하는 PC를 생각해보자. 보통의 경우, 하드웨어 하나에 OS 하나를 설치하고 그 위에서 각자가 필요한 프로그램들을 설치해서 사용한다. 일반적인 사용자들의 경우 이렇게 사용하더라도 큰 문제가 생길 위험이 크게 없다. 만일 생기더라도 재부팅하는 식의 방법으로 간단하게 해결하면 그만이다. 

하지만, 기업에서 소프트웨어를 개발하고 운영하는 과정에서 소프트웨어 간의 간섭으로 문제가 발생한다면, 단순히 재부팅하는 수준의 문제가 아닐 것이다. 경제적, 시간적 비용이 막대하게 생길 것이 뻔하며, 이를 방지하기 위해 가상화 기술이 반드시 필요하다.



가상화 기술을 사용하지 않는 경우와 사용하는 경우를 아래와 같이 정리할 수 있다.

## 단일 OS에서 여러 개의 소프트웨어를 동작시키는 상황 (Baremetal)

* 특정 프로그램의 사용량이 급증하거나, 문제를 일으켜 다른 프로그램의 동작을 방해할 수 있다.

## 가상화 기술을 통해 생성된 여러 OS를 사용하여  소프트웨어를 동작시키는 상황 (Virtualiztion)

* 가상화 기술을 사용하면 한 대의 컴퓨터에서 여러 대의 논리적인 OS 환경을 만들 수 있다.
* 이때, 사용자가 개별 OS에서 사용할 리소스를 직접 분배가 가능하다.
* 개별 OS에서 실행되는 각각의 프로그램들은 논리적으로 격리되어 실행된다.



## 가상화 방식

가상화를 하는 방식은 크게 **하이퍼바이저 방식**과 **컨테이너 방식** 둘로 분류한다. 

### 하이퍼바이저(Hypervisor) 가상화

* 하이퍼바이저 가상화는 말 그대로 하이퍼바이저라는 소프트웨어 기술을 통해 구현되는 가상화 방식이다.
* 하이퍼바이저는 간단하게 컴퓨터에 설치되는 프로그램 정도로 이해하면 괜찮다.
* 즉, 하이퍼바이저라는 프로그램을 OS 위에서 구동시켜서 가상화 환경을 관리한다.
* 가상 OS를 만들면 사용자가 지정해놓은 CPU와 메모리 만큼 컴퓨터의 격리된 공간을 만들어낼 수 있다.
* 가상 환경을 만들 때마다 사용자가 지정한 만큼의 디스크 공간, CPU, 메모리를 사용하게 된다.
* 여기서 하이퍼바이저가 구동되는 OS를 호스트 OS라고 부르며, 하이퍼바이저에 의해 생성된 가상화 OS들을 게스트 OS라고 부른다.
* 호스트 OS : 물리적인 서버에 설치되는 OS
  * 하이퍼바이저를 설치해서 가상환경을 만들 수 있다.
  * 하이퍼바이저는 호스트 OS의 자원을 격리해서 새로운 OS를 만들어 실행한다.
* 게스트 OS : 하이퍼바이저를 통해 생성된 OS
  * 호스트 OS의 리소스를 나누어 만들어진 논리적인 공간
  * 일반적으로 가상머신이라고 부른다.
  * Web Server나 WAS, DB 같은 서버 프로그램을 프로세스 형태로 실행해서 운영한다.
* 가상화 과정 (상세)
  * 프로세스가 정상적으로 실행되기 위해서는 CPU, 메모리와 같은 하드웨어 자원이 필요하다. 하지만, 프로세스는 하드웨어 자원에 임의로 접근할 수 없도록 설계되어 있다. 하드웨어 자원을 사용하는 것은 아주 복잡하고 조심스러운 과정이기 때문이다.
  * 프로세스가 하드웨어에 접근하기 위해서 OS에 설치된 커널을 거쳐야만 한다. 커널은  **시스템 콜(system call)**이라는 표준을 통해 하드웨어 자원 사용 요청을 대신 전달한다.
  * 보통 사용하는 프로그램들 역시 실행될 때 프로세스들은 OS의 커널에게 하드웨어 자원을 요청하여 사용한다.
  * 게스트 OS들은 실제로 물리적인 하드웨어가 없기 때문에 호스트 OS에 설치된 커널을 통해 하드웨어 자원 사용을 요청해야 한다.
  * 하지만, 호스트 OS와 게스트 OS가 종류가 다르다면, 호스트 OS는 게스트 OS에서 전달받은 시스템 콜(system call)을 처리할 수 없다.
  * 이때, 하이퍼바이저가 서로 다른 커널 간의 언어를 통역하는 역할을 하여 게스트 OS의 시스템콜을 호스트 OS가 처리할 수 있도록 해준다. 
  * 커널 간 번역 과정을 거쳐가기에 처리 과정이 복잡하며 이를 **오버헤드가 크다**고 표현한다.

### 컨테이너(Container) 가상화

* 컨테이너 가상화는 도커가 사용하는 가상화 방식이다.
* 하이퍼바이저 없이 리눅스 커널이 제공하는 LXC(LinuX Containers)라는 자체 격리 기술을 활용하여 가상화를 수행한다.
* 커널의 격리 기능을 활용하기 때문에 모든 컨테이너들은 호스트 OS의 커널을 공유한다.
* 호스트 OS의 커널을 그대로 사용하므로 중간 단계가 없으며 하드웨어 자원 사용 요청이 더욱 효율적으로 이루어질 수 있다. 이를 **오버헤드가 적다**라고 표현한다.
* 컨테이너들은 자체적인 커널을 가지지 않고 호스트 OS의 커널을 공유하기에 커널 실행 시간 자체가 없으며 매우 **빠른 부팅**이 가능하다.
* 보안적인 측면에서는, 커널을 독립적으로 가지는 하이퍼바이저 방식이 조금 더 뛰어나다고 볼 수 있다.
* 컨테이너는 호스트 OS의 커널을 공유하기 때문에 호스트 OS와 다른 종류의 OS는 실행할 수 없다는 것이 가장 큰 단점이다.

---



# 도커 (Docker)

## 도커란

* 컨테이너 가상화를 하기 위한 도구이다.
* 컨테이너 플랫폼
  * 컨테이너 엔진
    * 사용자의 요청을 받아 컨테이너를 관리한다.
  * 컨테이너 런타임
    * 직접 커널과 통신하면 실제로 격리된 공간을 만든다.
    * runc : 도커가 지원하는 기본 컨테이너 런타임

## 도커 아키텍쳐

* Client - Server 모델로 실행된다.
* Client : 사용자의 명령을 Docker Demon이라는 서버에 전달한다.
* Demon Server : 실제로 컨테이너를 관리해주는 기능을 제공하며 도커D라고도 부른다.
  * 호스트 OS에서 지속적으로 실행되면서 클라이언트의 요청에 따라서 컨테이너를 관리한다
  * 호스트 OS의 커널의 기능을 활용하여 컨테이너를 관리한다.
  * Client가 원하는 기능을 실행할 수 있도록 API를 제공한다.
    * API :  상호 간의 주고받는 데이터의 약속된 양식을 의미한다.
  * 컨테이너를 생성하려면 컨테이너 생성 api 요청을 보내야하고, 삭제하려면 삭제 api 요청을 보내야 한다. 하지만, api는 복잡한 양식으로 구성되어 있어 사용이 어렵다.
* Docker CLI (Command Line Interface)
  * Client가 API를 직접 사용하기에 번거롭다 보니, Docker에서는 Docker CLI를 통해 사용자의 명령을 쉽게 전달할 수 있도록 제공한다.
  * Client가 터미널 창에 명령어를 입력하면 명령어를 서버에서 사용되는 API 양식에 맞게 만들어 대신 전달한다. 이 덕분에 도커 데몬의 API와 쉽게 통신할 수 있다.

##  도커 이미지

### 프로그램이 실행되려면

* 서버에서 소프트웨어를 작동시키고자 할 때, 해당 소프트웨어만 있으면 될까? 아니다. 하나의 소프트웨어를 동작시키려면 다음과 같은 요소들이 필요하다,
* OS : 소프트웨어가 하드웨어의 자원을 사용할 수 있게 한다.
* 패키지, 라이브러리 : 해당 소프트웨어가 실행되기 위해 필요한 사전 구성 요소들이다.
* 런타임 언어 : 프로그램을 실행시키기 위한 요소 ex) Java 소프트웨어 -> Java 런타임 필요
* 이처럼 하나의 프로그램을 실행하기 위해서는 정말 많은 것들을 고려해야한다.

### 여기서, 도커를 사용하면

* 도커 이미지를 사용하면 OS, 패키지, 라이브러리, 런타임 언어 이것들을 매번 설치하지 않고 사용하도록 할 수 있다.
* 도커 이미지(Image) : 특정 시점의 파일 시스템 (디렉토리)를 저장한 압축 파일이다.
* 이미지는 제작 단계부터 소프트웨어를 비롯해 소프트웨어를 실행하는데 필요한 모든 요소들을 사전에 준비하여 압축한다.
* 즉, 이미지 내부에는 OS, 소프트웨어, 소프트웨어 작동에 필요한 모든 요소들이 모두 포함된 것이다.
* 이처럼 도커를 사용하면, 사용자가 매번 소프트웨어 동작을 가능하도록 환경을 조성하는 과정을 하지 않아도 되어 매우 편리하다.

### 이미지는 백업(Backup)으로 이해해보자

* 컴퓨터나 스마트폰에서 필요한 프로그램이나 어플리케이션들을 설치한 상태에서 백업을 하여 그 상태를 저장하면 문제가 생겼을 때 언제든 백업된 시점으로 돌아갈 수 있다.
* 도커 이미지 역시 백업된 형태로 존재하면서 사용자가 그 시점 상태를 유지하면서 프로그램을 실행할 수 있다.
* 사용자가 원하는 경우, 새로운 시점에 추가적인 백업을 진행하여 새로운 이미지를 생성할 수도 있다.
* 백업 파일을 공유할 수 있듯이, 도커 이미지 역시 외부와 공유가 가능하다.
* 도커 이미지는 일반적인 백업 파일들과 다르게 압축 파일의 사이즈가 매우 작아 인터넷을 통해 저장 및 공유하기에 매우 유용하다.
* 이미지는 공유받아 사용할 수도 있으며, 사용자가 직접 제작할 수도 있다.

## 이미지와 컨테이너

이미지는 이쯤이면 이해가 되었을 것이다. 그럼 컨테이너는 뭘까? 컨테이너의 개념은 프로그램과 프로세스의 관계로 생각하면 이해가 쉽다. 프로그램과 프로세스 개념을 먼저 이해해보자.

### 프로그램 vs 프로세스

* 컴퓨터에 어떤 프로그램 설치파일을 다운받아 설치를 진행하는 경우, 시스템 드라이브인 C드라이브의 시스템 공간을 점유하면서 설치된다.
* 이렇게 설치되어 실행되지 않고 있는 상태는 **프로그램 상태**로 CPU, 메모리와 같은 하드웨어 자원을 사용하지 않으며, 오로지 저장공간만 차지한 상태로 머무른다.
* 프로그램을 누르게 되면, 이때부터 프로그램은 프로세스가 되어 구동된다.
* 프로그램 (Program) : 실행 가능한 소프트웨어로 디스크 공간을 차지한다.
* 프로세스 (Process) : 실행 상태의 소프트웨어이다.
  * 하나의 프로그램으로부터 N개의 프로세스 실행이 가능하다.
  * 프로세스는 CPU, 메모리와 같은 하드웨어 자원을 사용한다.

프로그램과 프로세스의 차이가 이해가 되었나? 그럼 프로그램을 이미지라고 프로세스를 컨테이너라고 동일하게 생각해서 이해하면 된다. 

### 이미지 vs 컨테이너

* 이미지 :  프로그램이 실행되기 위한 환경이 모두 포함되어 있는 파일 시스템이다.
  * 시스템의 디스크 공간만을 차지한다.
* 컨테이너 : 실행 상태의 이미지이다.
  * 컨테이너를 생성하기 위해서는 이미지 파일이 반드시 필요하다.
  * 하나의 이미지로 N개의 컨테이너를 실행할 수 있다.
  * 동일한 이미지에서 실행한 컨테이너는 내부에서 모두 동일한 프로세스로 실행된다.
  * 컨테이너는 CPU, 메모리와 같은 하드웨어 자원을 사용한다.
  * 컨테이너가 실행될 때에는 격리된 공간이 생성되며, 이 공간에서 사전에 지정한 프로그램이 프로세스로 실행된다.
